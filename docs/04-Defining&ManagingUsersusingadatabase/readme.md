# 04 - Defining & Managing Users using a database

## 001 Quick revision of enhancements done so far
![alt text](image.png)

The image provides a flow that illustrates different ways user details and credentials can be managed within a Spring Security context in a Spring Boot application. Let's break down the four stages depicted in the diagram and explain each one with examples:

---

### 1. **Password in Console Logs**

This likely refers to the **default behavior** of Spring Boot applications that include Spring Security but haven't configured custom security settings. When Spring Security is enabled but no users are defined, Spring Boot auto-generates a default password and prints it in the console logs.

- **Example**:
  When you start a Spring Boot application with Spring Security, you may see something like this in the console:
  
  ```plaintext
  Using default security password: b3a1d5e4-6f7a-4d9a-83de-0f7a71b39d12
  ```
  
  This behavior is for quick setup during development but is insecure for production environments. The password in the console is meant to be changed as soon as you configure users.

---

### 2. **User Details in application.properties**

The next stage illustrates user credentials being defined in the `application.properties` file. This is an easy, lightweight way to store user information, especially during development or testing.

- **Example**:
  You can configure the username and password in `application.properties` like this:
  
  ```properties
  spring.security.user.name=user1
  spring.security.user.password=secret
  ```

- **How it works**:
  Spring Boot will read these values and create a basic in-memory user with the specified credentials. This is useful for quick setups but should not be used in production as it lacks flexibility, especially with roles, and storing plain-text passwords in properties is not secure.

---

### 3. **User Details in Memory of the Application**

At this stage, we are moving towards a more flexible and common approach: storing user credentials in memory using the `InMemoryUserDetailsManager`. This approach is configured programmatically inside your Spring Security configuration file.

- **Example**:
  
  ```java
  @Bean
  public UserDetailsService userDetailsService() {
      UserDetails user = User.withUsername("user")
                             .password("{noop}password") // No encoding, just for testing
                             .authorities("ROLE_USER")
                             .build();
                             
      return new InMemoryUserDetailsManager(user);
  }
  ```

- **Explanation**:
  Here, the `InMemoryUserDetailsManager` stores user details in memory (inside the application's runtime). This means you can add multiple users and configure their roles/authorities, but once the application is restarted, these details are lost. This approach is useful for testing but not recommended for production.

---

### 4. **User Details in DB (Database)**

The final stage shows a more production-ready setup where user details are stored in a **database** (DB). This approach is the most secure and scalable, allowing you to store, update, and manage user credentials persistently.

- **Example**:

  To store user details in a database, you typically use the `JdbcUserDetailsManager` or a custom `UserDetailsService` that fetches data from a relational database.

  ```java
  @Autowired
  DataSource dataSource;

  @Bean
  public UserDetailsManager userDetailsManager() {
      return new JdbcUserDetailsManager(dataSource);
  }
  ```

  **Table Structure**:
  You would need to create specific tables for users and authorities (roles). An example structure is:

  ```sql
  CREATE TABLE users (
      username VARCHAR(50) PRIMARY KEY,
      password VARCHAR(100),
      enabled BOOLEAN
  );

  CREATE TABLE authorities (
      username VARCHAR(50),
      authority VARCHAR(50),
      FOREIGN KEY (username) REFERENCES users(username)
  );
  ```

- **Explanation**:
  Storing user details in a database provides persistence, scalability, and security. You can easily add, update, or delete users, manage roles, and ensure passwords are hashed (using password encoders such as BCrypt). This method is widely used in production environments for web applications that require user authentication.

---

### **Summary:**

1. **Password in Console Logs**: The default password generated by Spring Security for development use.
2. **User Details in application.properties**: Quick setup for storing a single user in `application.properties`, useful for testing.
3. **User Details in Memory**: Using `InMemoryUserDetailsManager` for in-memory user storage, convenient for testing but not persistent.
4. **User Details in DB**: Storing user details in a database for production-level security, flexibility, and persistence. This method involves using `JdbcUserDetailsManager` or implementing a custom `UserDetailsService` that fetches data from the database.

Each of these methods offers increasing levels of flexibility and security, with database storage being the most robust and recommended for production environments.


## 002 Creating MySQL Database using Docker

```yaml
version: '3.8'  # This specifies the version of Docker Compose, 3.8 is compatible with the latest versions.

services:
  mysql:
    image: mysql:latest  # Pulls the latest version of MySQL.
    container_name: springsecurity
    environment:
      MYSQL_ROOT_PASSWORD: root  # Root password for MySQL.
      MYSQL_DATABASE: bankdb     # The database that will be created.
    ports:
      - "3306:3306"  # Exposes MySQL on port 3306 to the host.
    volumes:
      - mysql_data:/var/lib/mysql  # Persists MySQL data even if the container is destroyed.
    networks:
      - springsecurity-network

volumes:
  mysql_data:  # Volume to persist data.

networks:
  springsecurity-network:
    driver: bridge  # Creates an isolated network for the MySQL container.

```

The dependency you provided:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-docker-compose</artifactId>
    <scope>runtime</scope>
</dependency>
```

### **Explanation of this Dependency:**

The `spring-boot-docker-compose` dependency is part of the Spring Boot ecosystem and is specifically designed to integrate Docker Compose with Spring Boot applications. When you add this dependency, Spring Boot becomes aware of Docker Compose and can automatically manage and orchestrate Docker Compose services as part of your application startup.

**Key Concepts:**

1. **`groupId` and `artifactId`:**
   - The `groupId` is `org.springframework.boot`, which means it's a Spring Boot-specific module.
   - The `artifactId` is `spring-boot-docker-compose`, which signifies that it's used for Docker Compose integration.

2. **`scope`:**
   - The `scope` is `runtime`, meaning that this dependency is only required at runtime, not at compile-time. This is because the dependency interacts with Docker Compose, which is part of the application's deployment, not the build process.

### **How It Works:**

When you include this dependency in your project, Spring Boot can automatically start Docker Compose services defined in your `docker-compose.yml` when the application starts. This makes it easier to manage dependent services like databases, messaging queues, or any other services defined in the Docker Compose file.

#### **Example Scenario:**

Imagine you have a Spring Boot application that depends on a MySQL database and a Redis instance. You typically define those services in a `docker-compose.yml` file. With the `spring-boot-docker-compose` dependency:

- Spring Boot will detect the `docker-compose.yml` file in the root of your project or in standard locations.
- It will automatically start the services (MySQL, Redis) when your Spring Boot application starts, ensuring that all required services are available before the application begins execution.
- It simplifies managing external services for local development or testing environments without needing to manually run `docker-compose up`.

### **Example Setup:**

#### **1. Docker Compose File (`docker-compose.yml`):**

```yaml
version: '3.8'
services:
  db:
    image: mysql:latest
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: testdb
    ports:
      - "3306:3306"
  redis:
    image: redis:latest
    ports:
      - "6379:6379"
```

#### **2. Spring Boot Application:**

```java
@SpringBootApplication
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

When you run this application, thanks to the `spring-boot-docker-compose` dependency, Spring Boot will automatically start the MySQL and Redis services defined in `docker-compose.yml`.

### **Benefits:**

1. **Automatic Service Management**: You no longer need to manually start Docker Compose services before running your application. Spring Boot will handle that for you.
   
2. **Improved Local Development**: For local development, it makes handling dependencies (such as databases or message brokers) easier, as they will start automatically alongside your application.

3. **Service Coordination**: If your application depends on multiple services (e.g., databases, caches, queues), `spring-boot-docker-compose` ensures that these services are started in the correct order and that they are running before your application begins.

### **Use Cases:**

- **Microservices**: When you're working with microservices architecture, and your Spring Boot service relies on other services (e.g., a discovery server, configuration server, databases, etc.), `spring-boot-docker-compose` helps manage these service dependencies.

- **Testing**: In integration testing environments, where your application needs external services like databases or caching systems, this dependency ensures that those services are available before tests are executed.

### **Summary:**

The `spring-boot-docker-compose` dependency integrates Docker Compose into your Spring Boot application's runtime, allowing for the automatic orchestration of Docker Compose services. It simplifies the management of external services required by your application during development or runtime by automatically starting and stopping them as needed.

## 003 Understanding JdbcUserDetailsManager & creating Users inside the DB

The SQL statements you provided create two tables: `users` and `authorities`. These tables are commonly used in Spring Security or similar authentication/authorization systems. Let’s break down the structure and purpose of each statement, with examples, to deeply understand how they work together.

### **1. Table Creation: `users`**

```sql
create table users
(
    username varchar(50) not null primary key,
    password varchar(500) not null,
    enabled boolean not null
);
```

#### **Explanation:**
- **`username`**: This column stores the unique username of the user. It is defined as `varchar(50)`, meaning it can store up to 50 characters. This field cannot be null (`not null`) and is also set as the **primary key**, ensuring each username is unique.
  
- **`password`**: This column stores the user's password. It is defined as `varchar(500)`, allowing up to 500 characters. The length of 500 is typically large to accommodate hashed passwords, which can be lengthy, especially when bcrypt or other strong hashing algorithms are used.
  
- **`enabled`**: This column stores a boolean value indicating whether the user is active or inactive. This is often used to disable accounts temporarily (e.g., locking accounts after multiple failed login attempts).

#### **Example:**
Imagine you have a user named `john_doe` with a password stored as a bcrypt hash and the user is currently active (enabled = `true`).

```sql
INSERT INTO users (username, password, enabled)
VALUES ('john_doe', '$2a$10$CwTycUXWue0Thq9StjUM0uJ8rzn3yRUaTflIcXZoFZJG8bJFm3uUm', true);
```
- The **username** is `john_doe`.
- The **password** is a bcrypt hash (the actual password could be something like `password123` before hashing).
- The **enabled** field is `true`, meaning the user can log in.

---

### **2. Table Creation: `authorities`**

```sql
create table authorities
(
    username varchar(50) not null,
    authority varchar(50) not null,
    constraint fk_authorities_users foreign key (username) references users (username)
);
```

#### **Explanation:**
- **`username`**: This column stores the username, and it must exist in the `users` table. It is defined as `varchar(50)` to match the `username` field from the `users` table. It is also marked as `not null`, ensuring that every row has a valid username.

- **`authority`**: This column stores the authority (or role) associated with the user. It is defined as `varchar(50)`, allowing a role name like `ROLE_USER`, `ROLE_ADMIN`, etc. It is also marked as `not null`.

- **Foreign Key Constraint (`fk_authorities_users`)**: This constraint ensures that the `username` in the `authorities` table must exist in the `users` table. In other words, you cannot assign an authority to a user that does not exist in the `users` table.

#### **Example:**
For example, assigning the role `ROLE_ADMIN` to `john_doe` would look like this:

```sql
INSERT INTO authorities (username, authority)
VALUES ('john_doe', 'ROLE_ADMIN');
```

In this case:
- `john_doe` is the user (referenced from the `users` table).
- `ROLE_ADMIN` is the authority or role being assigned to this user.

---

### **3. Unique Index Creation:**

```sql
create unique index ix_auth_username on authorities (username, authority);
```

#### **Explanation:**
- **Unique Index (`ix_auth_username`)**: This index ensures that each combination of `username` and `authority` in the `authorities` table is unique. This means a user can have multiple authorities (e.g., `ROLE_USER` and `ROLE_ADMIN`), but they cannot be assigned the same authority more than once.

- **Purpose of Index**: Indexes improve the performance of queries, especially when searching by `username` and `authority`. The unique constraint here enforces that there are no duplicate authority entries for the same user.

#### **Example:**
The following scenario would **not** be allowed due to the unique constraint on `username` and `authority`:

```sql
INSERT INTO authorities (username, authority)
VALUES ('john_doe', 'ROLE_ADMIN');
```

If `john_doe` already has `ROLE_ADMIN`, this insertion would fail, preventing duplicate role assignments for the same user.

---

### **Putting It All Together:**

The `users` and `authorities` tables are used to manage users and their roles (or authorities) in many applications, particularly those using **Spring Security**.

#### **How These Tables Work Together:**
1. **`users` table**: Contains all the users and their basic information such as username, password, and whether the user is enabled or disabled.
  
2. **`authorities` table**: Contains the authorities (roles) for each user. Multiple authorities can be associated with a single user, allowing for fine-grained control over user permissions.

#### **Example Use Case in an Authentication System**:
1. A user tries to log in with a username (`john_doe`) and password.
2. The system verifies the password by fetching the hashed password from the `users` table.
3. If the password matches and the user is enabled, the system looks up the roles (authorities) for that user in the `authorities` table (e.g., `ROLE_ADMIN`, `ROLE_USER`).
4. The user is authenticated and given access to resources based on the authorities (roles) assigned.

---

### **Full Example:**

```sql
-- Create the users table
CREATE TABLE users (
    username VARCHAR(50) NOT NULL PRIMARY KEY,
    password VARCHAR(500) NOT NULL,
    enabled BOOLEAN NOT NULL
);

-- Create the authorities table
CREATE TABLE authorities (
    username VARCHAR(50) NOT NULL,
    authority VARCHAR(50) NOT NULL,
    CONSTRAINT fk_authorities_users FOREIGN KEY (username) REFERENCES users (username)
);

-- Create unique index to ensure no duplicate authorities for the same user
CREATE UNIQUE INDEX ix_auth_username ON authorities (username, authority);

-- Insert a user into the users table
INSERT INTO users (username, password, enabled) 
VALUES ('john_doe', '$2a$10$CwTycUXWue0Thq9StjUM0uJ8rzn3yRUaTflIcXZoFZJG8bJFm3uUm', true);

-- Assign roles to the user
INSERT INTO authorities (username, authority)
VALUES ('john_doe', 'ROLE_USER');

INSERT INTO authorities (username, authority)
VALUES ('john_doe', 'ROLE_ADMIN');
```

### **Summary:**
- **`users` table**: Stores user details like `username`, `password`, and whether the user is enabled.
- **`authorities` table**: Stores the roles/authorities assigned to users.
- **Foreign key constraint**: Ensures that the `username` in `authorities` references an existing user in `users`.
- **Unique index**: Prevents duplicate role entries for the same user.

## 004 Using JdbcUserDetailsManager to perform authentication
## 005 Creating our own custom tables for Authentication
## 006 Creating JPA Entity and repository classes for new table
## 007 Creating our own custom implementation of UserDetailsService
## 008 Building a new REST API to allow the registration of new User
