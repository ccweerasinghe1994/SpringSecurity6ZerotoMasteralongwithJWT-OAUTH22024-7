# 04 - Defining & Managing Users using a database

## 001 Quick revision of enhancements done so far
![alt text](image.png)

The image provides a flow that illustrates different ways user details and credentials can be managed within a Spring Security context in a Spring Boot application. Let's break down the four stages depicted in the diagram and explain each one with examples:

---

### 1. **Password in Console Logs**

This likely refers to the **default behavior** of Spring Boot applications that include Spring Security but haven't configured custom security settings. When Spring Security is enabled but no users are defined, Spring Boot auto-generates a default password and prints it in the console logs.

- **Example**:
  When you start a Spring Boot application with Spring Security, you may see something like this in the console:
  
  ```plaintext
  Using default security password: b3a1d5e4-6f7a-4d9a-83de-0f7a71b39d12
  ```
  
  This behavior is for quick setup during development but is insecure for production environments. The password in the console is meant to be changed as soon as you configure users.

---

### 2. **User Details in application.properties**

The next stage illustrates user credentials being defined in the `application.properties` file. This is an easy, lightweight way to store user information, especially during development or testing.

- **Example**:
  You can configure the username and password in `application.properties` like this:
  
  ```properties
  spring.security.user.name=user1
  spring.security.user.password=secret
  ```

- **How it works**:
  Spring Boot will read these values and create a basic in-memory user with the specified credentials. This is useful for quick setups but should not be used in production as it lacks flexibility, especially with roles, and storing plain-text passwords in properties is not secure.

---

### 3. **User Details in Memory of the Application**

At this stage, we are moving towards a more flexible and common approach: storing user credentials in memory using the `InMemoryUserDetailsManager`. This approach is configured programmatically inside your Spring Security configuration file.

- **Example**:
  
  ```java
  @Bean
  public UserDetailsService userDetailsService() {
      UserDetails user = User.withUsername("user")
                             .password("{noop}password") // No encoding, just for testing
                             .authorities("ROLE_USER")
                             .build();
                             
      return new InMemoryUserDetailsManager(user);
  }
  ```

- **Explanation**:
  Here, the `InMemoryUserDetailsManager` stores user details in memory (inside the application's runtime). This means you can add multiple users and configure their roles/authorities, but once the application is restarted, these details are lost. This approach is useful for testing but not recommended for production.

---

### 4. **User Details in DB (Database)**

The final stage shows a more production-ready setup where user details are stored in a **database** (DB). This approach is the most secure and scalable, allowing you to store, update, and manage user credentials persistently.

- **Example**:

  To store user details in a database, you typically use the `JdbcUserDetailsManager` or a custom `UserDetailsService` that fetches data from a relational database.

  ```java
  @Autowired
  DataSource dataSource;

  @Bean
  public UserDetailsManager userDetailsManager() {
      return new JdbcUserDetailsManager(dataSource);
  }
  ```

  **Table Structure**:
  You would need to create specific tables for users and authorities (roles). An example structure is:

  ```sql
  CREATE TABLE users (
      username VARCHAR(50) PRIMARY KEY,
      password VARCHAR(100),
      enabled BOOLEAN
  );

  CREATE TABLE authorities (
      username VARCHAR(50),
      authority VARCHAR(50),
      FOREIGN KEY (username) REFERENCES users(username)
  );
  ```

- **Explanation**:
  Storing user details in a database provides persistence, scalability, and security. You can easily add, update, or delete users, manage roles, and ensure passwords are hashed (using password encoders such as BCrypt). This method is widely used in production environments for web applications that require user authentication.

---

### **Summary:**

1. **Password in Console Logs**: The default password generated by Spring Security for development use.
2. **User Details in application.properties**: Quick setup for storing a single user in `application.properties`, useful for testing.
3. **User Details in Memory**: Using `InMemoryUserDetailsManager` for in-memory user storage, convenient for testing but not persistent.
4. **User Details in DB**: Storing user details in a database for production-level security, flexibility, and persistence. This method involves using `JdbcUserDetailsManager` or implementing a custom `UserDetailsService` that fetches data from the database.

Each of these methods offers increasing levels of flexibility and security, with database storage being the most robust and recommended for production environments.


## 002 Creating MySQL Database using Docker

```yaml
version: '3.8'  # This specifies the version of Docker Compose, 3.8 is compatible with the latest versions.

services:
  mysql:
    image: mysql:latest  # Pulls the latest version of MySQL.
    container_name: springsecurity
    environment:
      MYSQL_ROOT_PASSWORD: root  # Root password for MySQL.
      MYSQL_DATABASE: bankdb     # The database that will be created.
    ports:
      - "3306:3306"  # Exposes MySQL on port 3306 to the host.
    volumes:
      - mysql_data:/var/lib/mysql  # Persists MySQL data even if the container is destroyed.
    networks:
      - springsecurity-network

volumes:
  mysql_data:  # Volume to persist data.

networks:
  springsecurity-network:
    driver: bridge  # Creates an isolated network for the MySQL container.

```

The dependency you provided:

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-docker-compose</artifactId>
    <scope>runtime</scope>
</dependency>
```

### **Explanation of this Dependency:**

The `spring-boot-docker-compose` dependency is part of the Spring Boot ecosystem and is specifically designed to integrate Docker Compose with Spring Boot applications. When you add this dependency, Spring Boot becomes aware of Docker Compose and can automatically manage and orchestrate Docker Compose services as part of your application startup.

**Key Concepts:**

1. **`groupId` and `artifactId`:**
   - The `groupId` is `org.springframework.boot`, which means it's a Spring Boot-specific module.
   - The `artifactId` is `spring-boot-docker-compose`, which signifies that it's used for Docker Compose integration.

2. **`scope`:**
   - The `scope` is `runtime`, meaning that this dependency is only required at runtime, not at compile-time. This is because the dependency interacts with Docker Compose, which is part of the application's deployment, not the build process.

### **How It Works:**

When you include this dependency in your project, Spring Boot can automatically start Docker Compose services defined in your `docker-compose.yml` when the application starts. This makes it easier to manage dependent services like databases, messaging queues, or any other services defined in the Docker Compose file.

#### **Example Scenario:**

Imagine you have a Spring Boot application that depends on a MySQL database and a Redis instance. You typically define those services in a `docker-compose.yml` file. With the `spring-boot-docker-compose` dependency:

- Spring Boot will detect the `docker-compose.yml` file in the root of your project or in standard locations.
- It will automatically start the services (MySQL, Redis) when your Spring Boot application starts, ensuring that all required services are available before the application begins execution.
- It simplifies managing external services for local development or testing environments without needing to manually run `docker-compose up`.

### **Example Setup:**

#### **1. Docker Compose File (`docker-compose.yml`):**

```yaml
version: '3.8'
services:
  db:
    image: mysql:latest
    environment:
      MYSQL_ROOT_PASSWORD: password
      MYSQL_DATABASE: testdb
    ports:
      - "3306:3306"
  redis:
    image: redis:latest
    ports:
      - "6379:6379"
```

#### **2. Spring Boot Application:**

```java
@SpringBootApplication
public class MyApplication {

    public static void main(String[] args) {
        SpringApplication.run(MyApplication.class, args);
    }
}
```

When you run this application, thanks to the `spring-boot-docker-compose` dependency, Spring Boot will automatically start the MySQL and Redis services defined in `docker-compose.yml`.

### **Benefits:**

1. **Automatic Service Management**: You no longer need to manually start Docker Compose services before running your application. Spring Boot will handle that for you.
   
2. **Improved Local Development**: For local development, it makes handling dependencies (such as databases or message brokers) easier, as they will start automatically alongside your application.

3. **Service Coordination**: If your application depends on multiple services (e.g., databases, caches, queues), `spring-boot-docker-compose` ensures that these services are started in the correct order and that they are running before your application begins.

### **Use Cases:**

- **Microservices**: When you're working with microservices architecture, and your Spring Boot service relies on other services (e.g., a discovery server, configuration server, databases, etc.), `spring-boot-docker-compose` helps manage these service dependencies.

- **Testing**: In integration testing environments, where your application needs external services like databases or caching systems, this dependency ensures that those services are available before tests are executed.

### **Summary:**

The `spring-boot-docker-compose` dependency integrates Docker Compose into your Spring Boot application's runtime, allowing for the automatic orchestration of Docker Compose services. It simplifies the management of external services required by your application during development or runtime by automatically starting and stopping them as needed.

## 003 Understanding JdbcUserDetailsManager & creating Users inside the DB
## 004 Using JdbcUserDetailsManager to perform authentication
## 005 Creating our own custom tables for Authentication
## 006 Creating JPA Entity and repository classes for new table
## 007 Creating our own custom implementation of UserDetailsService
## 008 Building a new REST API to allow the registration of new User
